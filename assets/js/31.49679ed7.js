(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{377:function(e,v,s){"use strict";s.r(v);var t=s(42),_=Object(t.a)({},(function(){var e=this,v=e.$createElement,s=e._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"前后端分离"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前后端分离"}},[e._v("#")]),e._v(" 前后端分离")]),e._v(" "),s("p",[e._v("前后端分离，最重要的分离点是接口。")]),e._v(" "),s("p",[e._v("从服务能力上划分，接口有两个层次：")]),e._v(" "),s("ol",[s("li",[e._v("基础业务服务")]),e._v(" "),s("li",[e._v("serverless服务")])]),e._v(" "),s("p",[e._v("基础业务服务，主要考虑领域模型，区分动静信息、深浅层次，提供元数据。主要由服务端同学维护。")]),e._v(" "),s("p",[e._v("serverless服务，主要考虑服务的聚合、筛选和其他通用函数。主要由前端同学维护。")]),e._v(" "),s("p",[e._v("从接口质量来考虑，需要实现：")]),e._v(" "),s("ol",[s("li",[e._v("单元测试")]),e._v(" "),s("li",[e._v("接口描述schema")])]),e._v(" "),s("p",[e._v("单元测试，要解决依赖服务（数据库、redis、kafka）的mock问题，才能保证单元测试的有效。主要由服务端同学维护。")]),e._v(" "),s("p",[e._v("接口描述schema，要解决接口文档的弱关系问题，实现接口的动态管理及数据的合法验证。由前端和服务端同学共同维护。")])])}),[],!1,null,null,null);v.default=_.exports}}]);